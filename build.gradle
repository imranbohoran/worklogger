plugins {
    id 'org.springframework.boot' version '2.4.1'
    id 'io.spring.dependency-management' version '1.0.10.RELEASE'
    id 'java'
    // Gradle plugin for printing pretty logs for gradle
    id "com.adarshr.test-logger" version "2.1.1"
}

ext.posgresContainerFromBuild = false

group = 'com.tib'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

repositories {
    // Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.flywaydb:flyway-core:6.4.3'

    runtimeOnly 'org.postgresql:postgresql'

    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
}

class EnsurePostgresAvailable extends DefaultTask {
    @Input
    int port

    @Input
    String hostName;

    @TaskAction
    void checkAndEnsurePostgresIsRunning() {
        println "Checking if expected port is been listed to. port - ${port}"
        // check if socket can be opened to port, if not call the docker compose
        try {
            def socket = new Socket(hostName, port)
            def bound = socket.isBound()
            println "Port bind status: ${bound}"
            socket.close()
        } catch (Exception ignored) {
            println "Nothing listening on port : ${port}. Starting docker..."
            project.ext.setProperty("posgresContainerFromBuild", true)
            def stdout = new StringWriter()
            def stderr = new StringWriter()
            ['/bin/sh', '-c', "docker-compose -f postgres-docker-compose.yaml up -d"].execute().waitForProcessOutput(stdout, stderr)

            sleep(5000)

            println "OUTPUT: " + stdout.toString()
            println "ERRORS: " + stderr.toString()
        }
    }
}

tasks.register("postgresCheck", EnsurePostgresAvailable) {
    group = 'Configure'
    description = 'Checks and ensures Postgress is running'
    port = 5432
    hostName = "localhost"
}

task('initialiseTestDB') {
    doLast {
        println ("Initialising the Test DB")
        def stdout = new StringWriter()
        def stderr = new StringWriter()
        ['/bin/sh', '-c', "./db/init_test_db.sh"].execute().waitForProcessOutput(stdout, stderr)

        println "OUTPUT: " + stdout.toString()
        println "ERRORS: " + stderr.toString()
    }
}

task('afterTest') {
    doLast {
        println "Cleaning up after test"
        if (posgresContainerFromBuild) {
            println "Container started from build. Cleaning postgres.."
            def stdout = new StringWriter()
            def stderr = new StringWriter()
            ['/bin/sh', '-c', "docker-compose -f postgres-docker-compose.yaml down"].execute().waitForProcessOutput(stdout, stderr)
            println "OUTPUT: " + stdout.toString()
            println "ERRORS: " + stderr.toString()
        } else {
            println "Nothing to clean up"
        }
    }
}

initialiseTestDB.dependsOn postgresCheck
test.dependsOn initialiseTestDB
test.finalizedBy afterTest

test () {
    useJUnitPlatform()
    testLogging {
        showStandardStreams = true
    }
}

